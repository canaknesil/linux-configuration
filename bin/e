#! /bin/bash


HELP_STR="Usage:
  e -h|--help
  Display help message

  e [--terminal] [--bind] [FILES...]
  New Emacs instance.

  e --client --terminal [FILES...]
  New Emacs client frame in terminal.

  e --client --new-frame [--bind] [FILES...]
  New Emacs client frame in X.

  e --client [--bind] FILES...
  Open files in the most recently created frame.
  Create new frame if necessary.

Options:
  --bind          Wait for Emacs to finish, either by quiting, or via C-#.
                  If not specified, return immediatelly.

  --client        Start Emacs as client. Start daemon if not running.
                  If not specified, start a new Emacs instance.

  -h, --help      Display help message and exit.

  --new-frame     Always create a new frame.

  --terminal      Start new frame in terminal.
                  If not specified, start new frames in X."


POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
	--client)
	    OPTARG_CLIENT=YES
	    shift
	    ;;
	# --display)
	#     OPTARG_DISPLAY="$2"
	#     shift
	#     shift
	#     ;;
	--terminal)
	    OPTARG_TERMINAL=YES
	    shift
	    ;;
	--bind)
	    OPTARG_BIND=YES
	    shift
	    ;;
	--new-frame)
	    OPTARG_NEW_FRAME=YES
	    shift
	    ;;
	-h|--help)
	    OPTARG_HELP=YES
	    shift
	    ;;
	-*|--*)
	    echo "Unknown option $1"
	    echo "$HELP_STR"
	    exit 1
	    ;;
	*)
	    POSITIONAL_ARGS+=("$1") # save positional arg
	    shift
	    ;;
    esac
done

FILES=$POSITIONAL_ARGS


if [ "$OPTARG_HELP" = YES ]; then
    echo "$HELP_STR"
    exit
fi


if [ "$(command -v emacsclientw)" ]; then
   ec=emacsclientw
else
   ec=emacsclient
fi

# From Emacs manual: due to limitations of MS-Windows, Emacs cannot
# have both GUI and text-mode frames in the same session. It also
# cannot open text-mode frames on more than a single Command Prompt
# window, because each Windows program can have only one console at
# any given time. For these reasons, if you invoke emacsclient with
# the -c option, and the Emacs server runs in a text-mode session,
# Emacs will always create a new text-mode frame in the same Command
# Prompt window where it was started; a GUI frame will be created only
# if the server runs in a GUI session. Similarly, if you invoke
# emacsclient with the -t option, Emacs will create a GUI frame if the
# server runs in a GUI session, or a text-mode frame when the session
# runs in text mode in a Command Prompt window.


if [ "$OPTARG_CLIENT" = YES ]; then
    if [ "$OPTARG_TERMINAL" = YES ]; then

	#
	# New Emacs client frame in terminal.
	#
	
	# e --client --terminal
	$ec -a "" -nw $FILES
	
    else
	if [ "$OPTARG_NEW_FRAME" = YES ]; then

	    #
	    # New Emacs client frame in X.
	    #

	    if [ "$OPTARG_BIND" = YES ]; then
		# e --client --new-frame --bind
		$ec -a "" -c $FILES
	    else
		# e --client --new-frame
		$ec -a "" -c -n $FILES
	    fi
	    
	else

	    #
	    # Open files in the most recently created frame. Create new frame if necessary.
	    #

	    if [ "${FILES[*]}" ]; then
		n_frames=$(emacsclient -e '(seq-length (frame-list))' 2>/dev/null)
		if [ "$OPTARG_BIND" = YES ]; then
		    # e --client --bind
		    if [ ! $n_frames ]; then
			$ec -a "" -c  $FILES
		    elif [ $n_frames -lt 2 ]; then
			$ec -a "" -c  $FILES
		    else
			$ec -a "" $FILES
		    fi
		else
		    # e --client
		    if [ ! $n_frames ]; then
			$ec -a "" -c -n $FILES
 		    elif [ $n_frames -lt 2 ]; then
 			$ec -a "" -c -n $FILES
 		    else
			$ec -a "" -n $FILES
 		    fi
		fi
	    else
		echo "No file is specified. Doing nothing."
		exit 1
	    fi
	    
	fi
    fi
else
    
    # 
    # New Emacs instance.
    #
    
    if [ "$OPTARG_TERMINAL" = YES ]; then
	if [ "$OPTARG_BIND" = YES ]; then
	    # e --terminal --bind
	    emacs -nw $FILES
	else
	    # e --terminal
	    emacs -nw $FILES 2>&1 >/dev/null & disown
	    # BUG: On Windows, above command leavs the shell currupted.
	    # Enter and arrow keys produce letters.
	fi
    else
	if [ "$OPTARG_BIND" = YES ]; then
	    # e --bind
	    emacs $FILES
	else
	    # e
	    emacs $FILES 2>&1 >/dev/null & disown
	    # BUG: On Windows, above command leavs the shell currupted.
	    # Enter and arrow keys produce letters.
	fi
    fi
    
fi
