#+TITLE: Basic Emacs Configuration
#+AUTHOR: Can Aknesil
#+STARTUP: content
#+OPTIONS: toc:nil

The configuration in emacs-base.org and emacs.org works with Emacs
version 29.1.

Emacs configuration is divided into two files:

emacs-base.org : Configuration that does not depend on additional
packages. Can be used when a basic, fast configuration is desired,
e.g. on a Raspberry Pi.

emacs.org : Remaining of the configuration that depends on additional
packages. Should be used in addition to emacs-base.org for full
configuration.

* Usage of emacs-base.org and emacs.org
On Windows, Gpg4win must be installed and accessible. Emacs does not
work correctly with GnuPG installed via MSYS2.

First, start Emacs with emacs-base.org only. Run M-x
package-refresh-contents. And exit.

Second, start Emacs with both emacs-base.org and emacs.org. Packages
will installed automatically.

Example .emacs file:

#+BEGIN_SRC emacs-lisp
  ;;(org-babel-load-file "~/Programs/linux-configuration/emacs-base.org")
  ;;(org-babel-load-file "~/Programs/linux-configuration/emacs.org")

  ;;(configure-font "Cascadia Code")
  ;;(configure-font-size 110)
#+END_SRC


* Initial configuration
** Home directory on Windows
#+BEGIN_SRC emacs-lisp
  ;; On Windows, if HOME environment variable is not defined, it is
  ;; automatically set to the user-specific application data directory,
  ;; where .emacs is expected to be. The actual location depends on the
  ;; Windows version. This can be overwritten by defining HOME
  ;; environment variable.

  ;; On Windows, the default directory at Emacs start-up depends on from
  ;; where it is started. find-file starts from the default
  ;; firectory. Changing it to the home directory.

  (when (eq system-type 'windows-nt)
    ;; In case HOME is not defined, save the old value and redefine it
    ;; to the correct location.
    (setenv "EMACS_HOME" (getenv "Home"))
    (setenv "Home" (getenv "UserProfile"))
    ;; Set the default-directory to home.
    (setq default-directory "~/"))
#+END_SRC


* Editing
** Line numbers
#+begin_src emacs-lisp
  (if (version<= "26.0.50" emacs-version)
      (global-display-line-numbers-mode)
    (global-linum-mode t))
#+end_src

** Theme
#+BEGIN_SRC emacs-lisp
  ;; To load custom theme
  ;;(load "~/emacs-themes/afternoon-theme-source-code.el")
  ;;(load-theme 'afternoon t)

  (load-theme 'tango-dark)

  ;; Beware that terminals use a smaller number of colors
  ;; (list-colors-display). If a non-supported color is entered, it is
  ;; replaced with the smallest-distanced supported color.


  ;; The following way of setting custom background is bad. It works
  ;; with x-display and with daemon but not with terminal display. When
  ;; running emacs from terminal (emacs -nw)
  ;; tty-run-terminal-initialization is called after the init file,
  ;; which sets the background to default via frame-set-background-mode.

  ;; Custom background (re-evaluate only first 2 lines to overwrite)
  ;;(setq my-custom-background "#300028")
  ;;(set-background-color my-custom-background) ;; Only sets current frame.
  ;; For future frames.
  ;; (add-hook 'after-make-frame-functions
  ;; 	  (lambda (frame)
  ;; 	    (select-frame frame)
  ;; 	    (set-background-color my-custom-background)))


  ;; Custom background
  (cond ((daemonp)
	 (set-face-background 'default "#1c1c1c") ;; daemon in terminal (emacsclient -nw)
	 (add-hook 'after-make-frame-functions    ;; daemon as window (emacsclient -c)
		   (lambda (frame)
		     (select-frame frame)
		     (when (display-graphic-p)
		       (set-background-color "#001800")))))
	((not (display-graphic-p)) (set-face-background 'default "#1c1c1c"))
	((display-graphic-p) (set-face-background 'default "#300028")))


  ;; Custom highigh background, default is too bright.
  ;; swiper-line-face inherits from highlight
  (set-face-attribute 'highlight nil :background "#807000")

  ;; show-paren-mode match background is too bright, not seeing the delimiter.
  (set-face-background 'show-paren-match "#990000")
  (set-face-foreground 'show-paren-match "#ccccff")
#+END_SRC

** Font and its size
#+BEGIN_SRC emacs-lisp
  ;; My old way of setting font and font size

  ;; (setq my-custom-font nil)
  ;; (setq my-custom-font-size nil)

  ;; (defun set-font (font)
  ;;   (set-face-attribute 'default nil :font font))

  ;; (defun set-font-size (font-size)
  ;;   (set-face-attribute 'default nil :height font-size))

  ;; (add-hook 'after-make-frame-functions
  ;; 	  (lambda (frame)
  ;; 	    (select-frame frame)
  ;; 	    (if my-custom-font
  ;; 		(set-font my-custom-font))
  ;; 	    (if my-custom-font-size
  ;; 		(set-font-size my-custom-font-size))))

  ;; ;; The following function should be called for font configuration.
  ;; (defun configure-font (font)
  ;;   (setq my-custom-font font)
  ;;   (set-font font))

  ;; (defun configure-font-size (font-size)
  ;;   "Font size is around 110."
  ;;   (setq my-custom-font-size font-size)
  ;;   (set-font-size font-size))


  ;; Font configuration given in Emacs manual
  (defun configure-font (font)
    (add-to-list 'default-frame-alist (cons 'font font)))

  ;; Usage example (font=Cascadia Code, fontsize=10):
  ;; (configure-font "Cascadia Code-10")
#+END_SRC

** TODO Highlight indentation
#+begin_src emacs-lisp
  ;; This is not good, only counts spaces.
  ;;(add-hook 'prog-mode-hook #'highlight-indentation-mode)
  ;; Experimental support for blank lines.
  ;;(setq highlight-indentation-black-lines t)

  ;; Find a good package.
#+end_src

** Line wrap for text buffers
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'text-mode-hook 'turn-on-auto-fill)

  (defun turn-on-visual-line-mode ()
    (visual-line-mode 1))

  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
  (add-hook 'prog-mode-hook 'turn-on-visual-line-mode)
  (add-hook 'org-mode-hook 'turn-on-visual-line-mode)


  ;; Unfil paragraph, reverse of fill-paragraph.
  ;; Taken from https://www.emacswiki.org/emacs/UnfillParagraph

  ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph    
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
	  ;; This would override `fill-column' if it's an integer.
	  (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  ;; Handy key definition
  (keymap-global-set "M-Q" #'unfill-paragraph)
#+END_SRC

** Show matching parenthesis
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-delay 0.0)
#+END_SRC

** Disable beeping
#+begin_src emacs-lisp
  ;; Visible bell instead of sound.
  ;;(setq visible-bell t)

  ;; Disable bell sound
  (setq ring-bell-function (lambda ()))
#+end_src

** On the fly spell check
#+BEGIN_SRC emacs-lisp
  ;; Requires an external spell checker, e.g. aspell.
  ;; Also requires a dictionary, e.g. aspell-en.

  ;; On the fly spell check for text 
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda ()
		     (flyspell-buffer)
		     (flyspell-mode 1))))
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

** CamelCase as separate words 
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'subword-mode)

  ;; Opposite of subword-mode is superword-mode.
#+END_SRC

** Enable mouse in terminal
#+BEGIN_SRC emacs-lisp
  (xterm-mouse-mode t)
#+END_SRC

** Delete selection when inserting text
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Preserve point location when scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-preserve-screen-position 1)

  ;; This doesn't preserve point location within window when pixel
  ;; scrolling, which is the desired behavior.
#+END_SRC

** Scroll margin
#+BEGIN_SRC emacs-lisp
  ;; Leave a number of lines on top or bottom when using C-l.  Also the
  ;; automatic scrolling is triggered when the point is this much close
  ;; to the top or the bottom.

  ;; Disadvantage: This prevents the point to move from one window to
  ;; other in follow-mode.

  ;; Disadvantage: Clicking to the lines at margin triggers
  ;; autoscrolling, which is distracting.

  ;; Compromising by setting scroll margin to a very small value.
  (setq scroll-margin 1)


  ;; Speficy margin for C-l.
  (setq recenter-positions '(middle 2 -2))
#+END_SRC

** Pixel scrolling
#+BEGIN_SRC emacs-lisp
  (pixel-scroll-precision-mode 1)
#+END_SRC

** Comment column
#+BEGIN_SRC emacs-lisp
  ;; Make M-; put the comment one space after the current lines text.
  (setq comment-column 0)
#+END_SRC

** Hide Scroll bar 
#+BEGIN_SRC emacs-lisp
  ;; Wrong way:
  ;; because display-graphic-p returns always nil when started as daemon.
  ;; (when (display-graphic-p) 
  ;;   (scroll-bar-mode -1))

  ;; scroll-bar-mode is void when opened in terminal mode. 
  (when (boundp 'scroll-bar-mode)
    (scroll-bar-mode -1))

  ;; Hide minibuffer scroll bar
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC


* Windows
** Move to, delete, or swap with another window directionally with windmove
#+BEGIN_SRC emacs-lisp
  ;; default key bindings are SHIFT-{left, right, up, down}.
  (windmove-default-keybindings)

  ;; default keybindings are C-x SHIFT-{left, right, up, down}.
  (if (version<= "28.1" emacs-version)
      (windmove-delete-default-keybindings))

  ;; default keybindings are SUPER-{left, right, up, down}.
  ;; Altering with C-SHIFT-{left, right, up, down}.
  (if (version<= "28.1" emacs-version)
      (windmove-swap-states-default-keybindings '(control shift)))
#+END_SRC

** Restore window configuration with winner mode
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

** Switch to new window after creation, delete window after killing buffer
#+BEGIN_SRC emacs-lisp
  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (defun delete-window-and-balance ()
    "Balance windows after invoking C-x 0."
    (interactive)
    (delete-window)
    (balance-windows))

  ;; Not needed. C-x 4 0 kill-buffer-and-window does the job.
  ;; (defun kill-buffer-and-delete-window ()
  ;;   "Delete current window after killing buffer, if there are more than 1 windows."
  ;;   (interactive)
  ;;   (kill-buffer)
  ;;   (if (> (count-windows) 1)
  ;;       (delete-window-and-balance)))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
  (global-set-key (kbd "C-x 0") 'delete-window-and-balance)
  ;;(global-set-key (kbd "C-x j") 'kill-buffer-and-delete-window)
#+END_SRC

** Tab bar (workspaces)
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-show nil)

  ;; Documentation is insufficient for tab-bar-tab-hints.
  ;;(setq tab-bar-tab-hints 1)

  ;; tab-bar-history-mode provides same functionality as
  ;; winner-mode. Even the key bindings are the same. Using winner-mode.

  ;;(tab-bar-history-mode 1)
#+END_SRC

* Frames
** Start as maximized window
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Hide tool bar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

** Hide menu bar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
#+END_SRC

** Undelete frame
#+BEGIN_SRC emacs-lisp
  (undelete-frame-mode 1)
#+END_SRC

** TODO Delete local buffers when deleting frames
#+BEGIN_SRC emacs-lisp
  (defvar server-clients)

  (defun can/delete-buffers-local-to-frame (frame)
    "Delete buffers that were exclusively seen by frame."
    (when (>= (seq-length (frame-list)) 2)
      (let* (;; buffers seen by the frame, except minibuffers,
	     ;; *Messages*, *scrath*.
	     (frame-buffers
	      (seq-filter (lambda (b)
			    (and (not (minibufferp b))
				 (not (string= (buffer-name b) "*Messages*"))
				 (not (string= (buffer-name b) "*scratch*"))))
			  (frame-parameter frame 'buffer-list)))

	     ;; buffers opened through the client arguments
	     ;; Client buffers are automatically killed and client is
	     ;; notified at frame deletion.
	     (client-buffers
	      (let ((proc (frame-parameter frame 'client)))
		(if (and proc (memq proc server-clients))
		    (process-get proc 'buffers)
		  nil)))

	     ;; buffers seen exclusively by other frames
	     (other-frames-buffers
	      (cl-reduce #'append
			 (mapcar (lambda (f)
				   (frame-parameter f 'buffer-list))
				 (seq-filter (lambda (f) (not (eq f frame)))
					     (frame-list)))))

	     ;; buffers that won't be deleted
	     (non-local-buffers (append client-buffers other-frames-buffers))

	     ;; buffers that will be deleted
	     (buffers-to-be-deleted
	      (seq-filter (lambda (x) (not (memq x non-local-buffers)))
			  frame-buffers)))

	(can/delete-buffers buffers-to-be-deleted))))


  (defun can/delete-buffers (buffers-to-be-deleted)
    "Delete buffers in buffers-to-be-deleted. Save beforehand if
   necessary. Prompt when saving."
    (save-some-buffers nil
		       (lambda ()
			 (and (buffer-file-name) ;; file visiting buffer
			      (memq (current-buffer) buffers-to-be-deleted))))

    (let ((killed-buffer-names
	   (seq-filter #'identity
		       (mapcar (lambda (b)
				 (let ((name (buffer-name b))
				       (res (kill-buffer b)))
				   (if res name nil)))
			       buffers-to-be-deleted))))

      (message "Killed buffers `%s'." killed-buffer-names)
      killed-buffer-names))


  (defun can/delete-frame ()
    "Delete frame. If there is only one frame, exit Emacs."
    (interactive)
    (if (>= (seq-length (frame-list)) 2)
	(delete-frame)
      (save-buffers-kill-terminal)))


  ;; Disagvantage: undelete-frame doesn't recreate deleted buffers.

  ;;(add-hook 'delete-frame-functions #'can/delete-buffers-local-to-frame)
  (global-set-key (kbd "C-x C-c") 'can/delete-frame)
#+END_SRC

** Ediff in a single frame
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** TODO Saving sessions
#+BEGIN_SRC emacs-lisp
  ;; Using built-in desktop library

  ;; Configure auto-saving desktops with auto-restoring, so that Emacs
  ;; doesn't start with the previous sessions configuration but the
  ;; previous session can be restores if desired.

  ;;(desktop-save-mode 1)
  ;;(setq desktop-restore-frames nil)
#+END_SRC


* Files
** TODO Save as (write-file and keep old buffer)
#+BEGIN_SRC emacs-lisp
  ;; Details need to be thought. E.g., what happens with an existing
  ;; file as the new file.

  ;; (defun can/write-file-new-buffer (filename)
  ;;   (interactive "FWrite file with new buffer: ")
  ;;   (let ((old-name (buffer-file-name)))
  ;;     (if old-name
  ;; 	(progn
  ;; 	  (find-file filename)
  ;; 	  (insert-file old-name))
  ;;       (message "Buffer is not visiting any file."))))
#+END_SRC

** All backups to a specific directory
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . "~/emacs-tmp")))
#+END_SRC

** Auto-save no message
#+BEGIN_SRC emacs-lisp
  (setq auto-save-no-message t)
#+END_SRC

** Recent files
#+BEGIN_SRC emacs-lisp
  ;; ivy-switch-buffer handles this

  ;; (recentf-mode 1)
  ;; (setq recentf-max-menu-items 25)
  ;; (setq recentf-max-saved-items 25)
  ;; (global-set-key "\C-x\ \M-f" 'recentf-open-files)

  ;; ;; Save recent file list every 5 min in case of abrupt exit.
  ;; (defun recentf-save-list-without-message ()
  ;;   (let ((inhibit-message t))
  ;;     (recentf-save-list)))

  ;; (run-at-time nil (* 5 60) 'recentf-save-list-without-message)

  ;; ;; Exclude internal recentf file.
  ;; (add-to-list 'recentf-exclude (expand-file-name recentf-save-file))
  ;; (recentf-cleanup)
#+END_SRC


* Miscellaneous
** Do not open startup GNU Emacs buffer
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

** Confirm closing
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC


* Programming languages & Modes
** Verilog
#+BEGIN_SRC emacs-lisp
  (setq verilog-auto-newline nil)
#+END_SRC
   
** Dired
#+BEGIN_SRC emacs-lisp
  ;; Dired ls options
  (setq-default dired-listing-switches "-alh")
#+END_SRC

** Vivado XDC
#+BEGIN_SRC emacs-lisp
  ;; Open in Tcl mode
  (add-to-list 'auto-mode-alist '("\\.xdc\\'" . tcl-mode))
#+END_SRC


* Shortcut commands
#+BEGIN_SRC emacs-lisp
  ;; Byte compile and load the elisp buffer
  (define-key emacs-lisp-mode-map (kbd "C-c C-c")
    'emacs-lisp-byte-compile-and-load)

  ;; Run .emacs
  (defun reload-config ()
    (interactive)
    (load-file "~/.emacs"))
#+END_SRC


* Done
#+BEGIN_SRC emacs-lisp
  (message "emacs-base.org last block done.")
#+END_SRC
